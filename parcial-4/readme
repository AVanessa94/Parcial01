# üìò Informe de Ejercicios  

## 1Ô∏è‚É£ Error en `invertir_lista` y c√≥digo `estructural.py` ‚Äì Programaci√≥n estructurada  

‚ö†Ô∏è **Problema detectado:**  
En la funci√≥n `invertir_lista`, el c√≥digo original estaba escrito de la siguiente manera:  

```python
print(invertir_lista([1,2,3,4,5])
En este caso, faltaba un par√©ntesis de cierre. El int√©rprete detecta que se abre una instrucci√≥n pero nunca se cierra, lo cual genera un error de sintaxis e impide que el programa pueda ejecutarse.

‚úÖ Correcci√≥n aplicada:
La soluci√≥n fue simplemente a√±adir el par√©ntesis faltante, quedando de la siguiente forma:

python
Copiar c√≥digo
print(invertir_lista([1,2,3,4,5]))
Con esta correcci√≥n, el programa se ejecuta correctamente y devuelve el resultado esperado.

üìù Explicaci√≥n del ejercicio estructurado:
En este archivo tambi√©n se plante√≥ un ejercicio cuyo objetivo era sumar todos los n√∫meros de una lista y, adem√°s, identificar el n√∫mero m√°ximo dentro de la misma. Se tuvo en cuenta el caso en el que la lista estuviera vac√≠a; en tal situaci√≥n, la funci√≥n deb√≠a retornar la tupla (0, None).

El funcionamiento consiste en inicializar las variables suma = 0 y maximo = lista[0]. Luego, se recorre la lista elemento por elemento. En cada iteraci√≥n:

El valor se acumula en la variable suma.

Si el n√∫mero actual es mayor que el valor almacenado en maximo, se actualiza dicho valor.

Al finalizar, la funci√≥n retorna la tupla con la suma total y el n√∫mero m√°ximo. Estos valores son mostrados en pantalla con mensajes que presentan los resultados.

üí° Este ejercicio demuestra c√≥mo aplicar estructuras de control simples para resolver un problema b√°sico de acumulaci√≥n y comparaci√≥n en listas.

2Ô∏è‚É£ Programaci√≥n Orientada a Objetos ‚Äì CuentaBancaria y Confirmacion
üè¶ Clase CuentaBancaria
Se desarroll√≥ una clase llamada CuentaBancaria que representa el modelo de una cuenta de ahorros simple. La clase contiene dos atributos principales: titular y saldo.

El m√©todo retirar permite restar una cantidad al saldo siempre que la cantidad sea positiva y que el saldo disponible sea suficiente. En caso contrario, el programa indica que los fondos son insuficientes.

üìå Explicaci√≥n paso a paso:

En el constructor __init__, se inicializan los valores del titular y el saldo.

El m√©todo retirar recibe como argumento la cantidad a retirar.

Si la cantidad es menor o igual a cero, se notifica que la cantidad no es v√°lida.

Si la cantidad es v√°lida y no supera el saldo disponible, se descuenta y se muestra el nuevo saldo.

En caso de no cumplir con las condiciones, el sistema informa que no hay fondos suficientes.

De esta forma, el programa logra simular de manera sencilla c√≥mo se realizan los retiros en una cuenta real.

‚úÖ Clase Confirmacion
Se dise√±√≥ una segunda clase llamada Confirmacion, enfocada en validar una compra seg√∫n el saldo disponible de un cliente.

El m√©todo confirmacion_compra recibe tres par√°metros: titular, saldo y el valor de la compra a comparar. Si el valor de la compra es menor o igual al saldo, se muestra un mensaje de confirmaci√≥n; de lo contrario, el sistema avisa que la compra excede el saldo disponible.

üìå Explicaci√≥n paso a paso:

Se inicializan los atributos del titular, saldo y el valor a comparar.

Si el valor de la compra es menor o igual al saldo, se imprime el mensaje de confirmaci√≥n y se retorna True.

Si el valor excede el saldo, se informa el monto disponible y se retorna False.

De esta manera, el programa simula un sistema de compras con validaci√≥n autom√°tica del saldo disponible, reforzando los conceptos de programaci√≥n orientada a objetos.

‚ú® Conclusi√≥n general:
Los ejercicios trabajados permitieron identificar y corregir errores de sintaxis en Python, aplicar estructuras de control b√°sicas para operaciones con listas, y finalmente implementar clases con atributos y m√©todos que representan escenarios de la vida real, como transacciones bancarias y validaci√≥n de compras.

